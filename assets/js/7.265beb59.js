(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{251:function(n,a,t){"use strict";t.r(a);var e=t(28),c=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"_1-jquery内部核心函数callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jquery内部核心函数callback"}},[n._v("#")]),n._v(" 1.jQuery内部核心函数callback")]),n._v(" "),t("p",[n._v("$.callback可以通过add添加回调函数，fire执行回调函数。初始化创建callback实例的时候，可以传递三个参数的组合，stopOnfalse表示如果其中一个回调函数的返回值是false,则后续的回调函数不再执行；once表示只执行一次，即add进去的回调函数只会在第一次fire的时候会执行，如果后面再继续调用fire,回调函数不会再执行；memory表示再调用fire函数以后，后面再继续调用add添加函数的时候，该回调函数会立即执行，且之前执行过的回调不会再被执行，以下是代码的完整简易实现，要点以及个人理解都在代码注释里面。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("var cb = $.callbacks('stopOnfalse once memory');\n\ncb.add(function(){\n    console.log(1)\n    return false\n}, function(){\n    console.log(2)\n});\n\ncb.add(function(){\n    console.log(5)\n});\n    \ncb.fire();\n\ncb.add(function(){\n    console.log('3')\n})\n")])])]),t("h2",{attrs:{id:"_2-callback之once"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-callback之once"}},[n._v("#")]),n._v(" 2.callback之once")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("var cb = $.callbacks('once');\n\ncb.add(function(){\n    console.log(1)\n});\n\ncb.fire(); //输出1\ncb.fire(); //没有输出\n")])])]),t("h2",{attrs:{id:"_3-callback之stoponfalse"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-callback之stoponfalse"}},[n._v("#")]),n._v(" 3.callback之stopOnfalse")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("var cb = $.callbacks('once');\n\ncb.add(function(){\n    console.log(1)\n    return false\n}, function(){\n    console.log(2)\n});\n\ncb.fire(); //输出1 \n")])])]),t("h2",{attrs:{id:"_4-callback之memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-callback之memory"}},[n._v("#")]),n._v(" 4.callback之memory")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("var cb = $.callbacks('stopOnfalse once memory');\n\ncb.add(function(){\n    console.log(1)\n});\n\ncb.add(function(){\n    console.log(5)\n});\n    \ncb.fire(); //输出1和5\n\n//会立即执行\ncb.add(function(){\n    console.log(3)\n})\n")])])]),t("p",[n._v("以上会分别输出1，5，3")]),n._v(" "),t("h2",{attrs:{id:"callback完整代码的简易实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#callback完整代码的简易实现"}},[n._v("#")]),n._v(" callback完整代码的简易实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("...\ncallbacks: function(option){\n    //回调函数列表 \n    var list = [],\n    //执行回调函数的下标 默认从第一个开始\n        index,\n    //手动设置执行回调函数列表的下标    \n        start,\n    //回调函数列表的长度\n        listLength,\n    //回调函数是否执行过\n        hasRun;\n    //当前回调队列策略 参数 once stopOnfalse memory\n    option = typeof option === 'string' ? (optionCach[option] || createOptionCach(option)) : {};\n    //当传进来的参数、模式不在缓存对象里面时候 需要重新创建\n    function createOptionCach(option){\n        //将空对象、缓存对象的对象引用给obj 并返回\n        var obj = optionCach[option] = {};\n        option.split(/\\s+/).forEach(function(opt){\n            obj[opt] = true;\n        });\n        return obj;\n    }\n    //循环执行回调函数列表里面的回调函数\n    var fire = function(data){\n        index = start || 0;\n        hasRun = true;\n        for(index; index < list.length; index++){\n            //如果回调函数的返回值是false 同时又配置了stopOnfalse的时候就跳出循环\n            if(list[index].apply(data[0], data[1]) == false && option.stopOnfalse){\n                break;\n            };\n        }\n    }\n    var self = {\n        add:function(){\n            var args = Array.prototype.slice.call(arguments);\n            //每次添加回调函数的时候 记录当前回调函数列表的长度\n            listLength = list.length;\n            //循环遍历args将add进来的回调函数全部放到事件列表list\n            args.forEach(function(fn){\n                //如果传进来的参数是函数对象 则添加到回调函数列表\n                if(toString.call(fn) === '[object Function]'){\n                    list.push(fn);\n                }\n            })\n            //当配置的memory的同时回调函数还没执行过 则将下次执行回调函数的下标置为当前事件列表的长度 避免执行的时候重复执行\n            if(option.memory && hasRun){\n                start = listLength;\n                self.fire(arguments);\n            }\n\n        },\n        fireWith:function(context, arg){\n            var args = [context, arg];\n            //如果是配置了只执行一次 或者还没执行过才执行\n            if(!option.once || !hasRun){\n                fire(args)\n            }\n            \n        },\n        fire:function(){\n            //把当前jQuery实例对象以及传递的参数通过fireWith传递\n            self.fireWith(this, arguments);\n        }\n    }\n    //这里返回self以实现链式调用\n    return self;\n}")])])])])}),[],!1,null,null,null);a.default=c.exports}}]);